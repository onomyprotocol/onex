
Replicated Security / ICS (originally "interchain-security" but partway through they decided to start changing to "replicated-security" which is why you will see mixed usage of these terms) has two modules, a provider module and a consumer module, that allow for the security of the provider chain with the provider module to be replicated onto the consumer chain with the consumer module.

Onomy's original main chain (https://github.com/onomyprotocol/onomy) is a provider chain. The ONEX chain and Arc chains are consumer chains in the Onomy network. For the ONEX chain, the market module is defined in https://github.com/onomyprotocol/market. The market/app/app.go doesn't have a consumer module, so it is just a standalone (I use the term "standalone" for something that can be run by itself without any ICS requirements) used for devnet testing. The onex repo (https://github.com/onomyprotocol/onex) imports the functional modules with an ICS consumer module to make the actual testnet and production binaries (see the branches for different chains).

We use a consumer-democracy model, which means that our consumer chains have normal governance and staking modules and thus can have a set of bonded validators.
The set of replicated security validators used by a consumer chain is _not_ related to the set of consumer-side bonded validators (in fact consumer chains start with zero bonded validators, as all the block-to-block signing is provided by the tendermint keys of the replicated security set). Currently, all that the bonded validators do is that they determine the governance voting powers. Depending on the chain, the bond token may be a newly minted token for the chain, an IBC token, or the future provider-driven governance will be used instead (https://github.com/cosmos/interchain-security/issues/1271).

The replicated security set is determined by the provider chain. Validators on the provider chain start out with their existing tendermint keys being used in the set, unless they change it with the `assign-consensus-key` command. See `bootstrapping.md` for how a consumer chain is run for the first time. When the validator set of the provider changes, ICS automatically creates IBC packets to be relayed to consumer chains, which when received will automatically update the replicated security set. Each validator on the provider chain should also run corresponding consumer nodes with their assigned consensus key, because otherwise they can be slashed for downtime.

# Onomy specific notes

Currently, we are using github.com/cosmos/interchain-security v1.1.0-multiden for our Producer and v1.2.0-multiden for our Consumers. Note that the canonical versions of the Producer and Consumers can be different. We always want to use versions that have been battle tested on Gaia. The version of interchain-security used has an exact SDK version that needs to be used with it. In the future, the ICS team plans to have all ICS functionality merged into the main Cosmos-SDK branch, but currently what we do is find the head commit of the ICS team's patches on Cosmos-SDK and branch it on our Onomy-SDK repo (https://github.com/onomyprotocol/onomy-sdk). We name it like "v0.45.16-ics-base". This base version will be used for chains that don't have any SDK patches of their own.

Our provider chain `onomy` has custom patches on top of Cosmos-SDK. What we do when updating is rebase those patches on the `-ics-base` commits to create a `-ics-onomy` branch such as https://github.com/onomyprotocol/onomy-sdk/tree/v0.45.16-ics-onomy (only use rebases or commit-by-commit cherry-picks, do not try to merge). This branch is then used by the `onomy` repo https://github.com/onomyprotocol/onomy along with the corresponding interchain-security producer version. The `super_orchestrator` tests should also be updated to correspond with the latest updates to `onomy_tests`.

We customized the PreCCV filtering (https://github.com/onomyprotocol/onex/blob/main/app/consumer-democracy/consumer-ante/msg_filter_ante.go)
to only allow certain `MsgConnectionOpenInit`s and `MsgChannelOpenInit`s that insure the first channel to be opened is the ICS channel (see `bootstrapping.md` for where this is used). ICS creates a transfer channel for rewards, and this same channel is what we use for the canonical IBC tokens from the producer. By insuring that `channel-1` is the transfer channel, it means that the IBC token can be determined ahead of chain genesis and be used in parameters without needing a governance change post launch.
